<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>アイドルライブ 3Dオタクシミュレーター</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* 3D描画エリア */
        #canvas-container {
            flex: 1; 
            width: 100%;
            position: relative;
            overflow: hidden;
            background: #111;
            min-height: 0;
        }

        /* UIパネルコンテナ */
        #ui-container {
            flex: 0 0 auto;
            background: #222;
            border-top: 1px solid #444;
            z-index: 100;
            transition: transform 0.3s ease-in-out;
            width: 100%;
            position: relative;
        }

        #ui-container.minimized {
            transform: translateY(calc(100% - 32px));
        }

        #toggle-btn {
            position: absolute;
            top: -24px;
            right: 10px;
            width: 40px;
            height: 24px;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-bottom: none;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 101;
        }
        #toggle-btn:hover { background: #666; }

        #ui-panel {
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            box-sizing: border-box;
        }

        .top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #eee;
            font-size: 12px;
            font-weight: bold;
            background: #333;
            padding: 4px 10px;
            border-radius: 4px;
        }
        .status-text { color: #ff0055; text-transform: uppercase; }
        .slider-wrapper { display: flex; align-items: center; gap: 8px; }
        input[type=range] { width: 100px; height: 4px; }

        .grid-row {
            display: grid;
            grid-template-columns: 1fr 1fr; 
            gap: 6px;
        }
        
        .ctrl-box {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .ctrl-label {
            font-size: 11px;
            color: #aaa;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            line-height: 1.1;
        }
        .ctrl-label span { font-size: 9px; color: #666; }
        
        .ctrl-buttons { display: flex; align-items: center; gap: 4px; }
        
        .btn-mini {
            width: 24px;
            height: 24px;
            background: #444;
            border: none;
            border-radius: 3px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn-mini:active { background: #666; }
        
        .count-text {
            font-family: monospace;
            color: white;
            font-size: 14px;
            width: 28px;
            text-align: center;
        }

        /* セキュリティの色 */
        .lbl-gentle { color: #8af; } /* 青系: 優しい */
        .lbl-scary { color: #f88; }  /* 赤系: 怖い */

        .action-scroll {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding-bottom: 4px;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }
        .action-scroll::-webkit-scrollbar { display: none; }

        .btn-action {
            flex: 0 0 auto;
            padding: 8px 14px;
            font-size: 12px;
            font-weight: bold;
            color: #ddd;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }
        .btn-action:active { background: #555; color: white; }
        .btn-red { background: #522; border-color: #844; color: #fdd; }

    </style>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-container">
        <div id="toggle-btn">▼</div>

        <div id="ui-panel">
            <!-- 1. ステータス & 速度 -->
            <div class="top-row">
                <div>STATE: <span id="statusText" class="status-text">IDLE</span></div>
                <div class="slider-wrapper">
                    <span>SPD</span>
                    <input type="range" id="speedSlider" min="0.1" max="3.0" step="0.1" value="1.0">
                    <span id="speedVal">1.0x</span>
                </div>
            </div>

            <!-- 2. 人数管理 -->
            <div class="grid-row">
                <div class="ctrl-box">
                    <div class="ctrl-label">前方オタク<span>(±10)</span></div>
                    <div class="ctrl-buttons">
                        <button class="btn-mini" id="btnFrontMinus">-</button>
                        <span id="countFront" class="count-text">0</span>
                        <button class="btn-mini" id="btnFrontPlus">+</button>
                    </div>
                </div>
                <div class="ctrl-box">
                    <div class="ctrl-label">後方オタク<span>(±10)</span></div>
                    <div class="ctrl-buttons">
                        <button class="btn-mini" id="btnRearMinus">-</button>
                        <span id="countRear" class="count-text">0</span>
                        <button class="btn-mini" id="btnRearPlus">+</button>
                    </div>
                </div>
                <!-- 優しいセキュリティ -->
                <div class="ctrl-box" style="border-color: #345;">
                    <div class="ctrl-label lbl-gentle">優しいセキュリティ<span>(±1)</span></div>
                    <div class="ctrl-buttons">
                        <button class="btn-mini" id="btnGentleMinus">-</button>
                        <span id="countGentle" class="count-text">0</span>
                        <button class="btn-mini" id="btnGentlePlus">+</button>
                    </div>
                </div>
                <!-- 怖いセキュリティ -->
                <div class="ctrl-box" style="border-color: #533;">
                    <div class="ctrl-label lbl-scary">怖いセキュリティ<span>(±1)</span></div>
                    <div class="ctrl-buttons">
                        <button class="btn-mini" id="btnScaryMinus">-</button>
                        <span id="countScary" class="count-text">0</span>
                        <button class="btn-mini" id="btnScaryPlus">+</button>
                    </div>
                </div>
            </div>

            <!-- 3. アクションボタン -->
            <div class="action-scroll">
                <button class="btn-action" id="btnIdle">棒立ち</button>
                <button class="btn-action" id="btnMosh">モッシュ</button>
                <button class="btn-action" id="btnCircleL">↺ 左回り</button>
                <button class="btn-action" id="btnCircleR">↻ 右回り</button>
                <button class="btn-action btn-red" id="btnWodPrep">WOD待機</button>
                <button class="btn-action btn-red" id="btnWodGo">WOD突撃</button>
                <button class="btn-action" id="btnReset">リセット</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 設定 ---
        const INITIAL_FRONT_COUNT = 40;
        const INITIAL_REAR_COUNT = 100;
        
        const STAGE_Z = -30;
        const BASE_MAX_SPEED = 0.2; 
        const FRICTION = 0.95;
        let globalSpeedMultiplier = 1.0;

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        scene.fog = new THREE.Fog(0x1a1a1a, 30, 100);

        const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 45, 65);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 10;
        controls.maxDistance = 150;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; 

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 60; dirLight.shadow.camera.bottom = -60;
        dirLight.shadow.camera.left = -60; dirLight.shadow.camera.right = 60;
        dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const spotLight = new THREE.SpotLight(0xffffff, 100);
        spotLight.position.set(0, 50, STAGE_Z + 15);
        spotLight.target.position.set(0, 0, STAGE_Z);
        spotLight.angle = Math.PI / 4;
        spotLight.penumbra = 0.5;
        scene.add(spotLight);
        scene.add(spotLight.target);

        // 前方オタク用補助ライト
        const frontFillLight = new THREE.PointLight(0xffddcc, 1.0, 40);
        frontFillLight.position.set(0, 10, -5); 
        scene.add(frontFillLight);

        // --- Objects ---
        const floorGeo = new THREE.PlaneGeometry(200, 200);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.6 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        const stageHeight = 4;
        const stageGeo = new THREE.BoxGeometry(60, stageHeight, 15);
        const stageMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const stage = new THREE.Mesh(stageGeo, stageMat);
        stage.position.set(0, stageHeight / 2, STAGE_Z);
        stage.castShadow = true;
        stage.receiveShadow = true;
        scene.add(stage);

        // Idol
        const idolGroup = new THREE.Group();
        const idolPosY = stageHeight + 1.25; 
        for(let i=-2; i<=2; i+=2){
            const bodyGeo = new THREE.CapsuleGeometry(0.7, 1.1, 4, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff99cc, emissive: 0xff55aa, emissiveIntensity: 0.6 });
            const idol = new THREE.Mesh(bodyGeo, bodyMat);
            idol.position.set(i*5, idolPosY, STAGE_Z);
            idol.castShadow = true;
            idolGroup.add(idol);
        }
        scene.add(idolGroup);

        // --- CLASSES ---
        class Character {
            constructor() {
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.isFallen = false;
                this.recoverTimer = 0;
            }
            dispose() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        class Otaku extends Character {
            constructor(id, isFrontRow, isFC) {
                super();
                this.id = id;
                this.isFrontRow = isFrontRow; 
                this.isFC = isFC;

                let colorVal;
                let emissiveInt = 0.5;
                if (this.isFC) {
                    colorVal = 0xff6600; emissiveInt = 0.2;
                } else {
                    const hue = Math.random();
                    colorVal = new THREE.Color().setHSL(hue, 0.8, 0.5);
                }

                const material = new THREE.MeshStandardMaterial({ 
                    color: colorVal, emissive: colorVal, emissiveIntensity: emissiveInt, roughness: 0.5
                });
                const geometry = new THREE.CapsuleGeometry(0.6, 1.8, 4, 8);
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.castShadow = true;
                this.mesh.userData = { owner: this };

                this.originalPos = new THREE.Vector3();
                this.setInitialPosition();
                this.noiseOffset = Math.random() * 100;
                scene.add(this.mesh);
            }

            setInitialPosition() {
                let x, z;
                if (this.isFrontRow) {
                    x = (Math.random() - 0.5) * 40;
                    z = -5 + (Math.random() - 0.5) * 8; 
                } else {
                    x = (Math.random() - 0.5) * 30;
                    z = 15 + (Math.random() - 0.5) * 15;
                }
                if (this.isFC) { x=0; z=15; }
                this.originalPos.set(x, 1.5, z);
                this.mesh.position.copy(this.originalPos);
                this.mesh.rotation.set(0,0,0);
                this.isFallen = false;
            }

            fall() {
                if (this.isFallen) return;
                this.isFallen = true;
                this.recoverTimer = 20 + Math.random() * 30;
                this.mesh.rotation.z = Math.PI / 2;
                this.mesh.rotation.y = Math.random() * Math.PI * 2;
                this.mesh.position.y = 0.6;
                this.velocity.multiplyScalar(0.5);
            }

            standUp() {
                this.isFallen = false;
                this.mesh.rotation.set(0,0,0);
                this.mesh.position.y = 1.5;
            }

            update(mode, allOtakus) {
                if (this.isFallen) {
                    this.recoverTimer--;
                    if (this.recoverTimer <= 0) this.standUp();
                    this.velocity.multiplyScalar(0.9);
                    this.mesh.position.add(this.velocity);
                    return;
                }

                const pos = this.mesh.position;
                let fx = 0, fz = 0;

                for (let other of allOtakus) {
                    if (other === this) continue;
                    const dx = pos.x - other.mesh.position.x;
                    const dz = pos.z - other.mesh.position.z;
                    const distSq = dx*dx + dz*dz;
                    const minDist = 1.3; 

                    if (distSq < minDist * minDist && distSq > 0) {
                        const dist = Math.sqrt(distSq);
                        const nx = dx / dist; const nz = dz / dist;
                        const push = (minDist - dist) * 0.5;
                        pos.x += nx * push; pos.z += nz * push;

                        const rvx = this.velocity.x - other.velocity.x;
                        const rvz = this.velocity.z - other.velocity.z;
                        const vNormal = rvx * nx + rvz * nz;

                        if (vNormal < 0) {
                            const j = -(1 + 1.2) * vNormal;
                            this.velocity.x += nx * j * 0.5;
                            this.velocity.z += nz * j * 0.5;
                            if (Math.abs(j) > 0.6 && Math.random() < 0.05) {
                                this.fall();
                                if(!other.isFrontRow && Math.random() < 0.5) other.fall();
                            }
                        }
                    }
                }

                const actualMaxSpeed = BASE_MAX_SPEED * globalSpeedMultiplier;
                
                if (this.isFrontRow) {
                    this.mesh.position.y = 1.5 + Math.abs(Math.sin(Date.now()*0.01*globalSpeedMultiplier + this.noiseOffset)) * 0.2;
                    fx += (this.originalPos.x - pos.x) * 0.1;
                    fz += (this.originalPos.z - pos.z) * 0.1;
                } else {
                    const centerX = 0; const centerZ = 15; 
                    switch (mode) {
                        case 'IDLE':
                            this.mesh.position.y = 1.5 + Math.abs(Math.sin(Date.now()*0.01*globalSpeedMultiplier + this.noiseOffset)) * 0.5;
                            fx += (this.originalPos.x - pos.x) * 0.02; fz += (this.originalPos.z - pos.z) * 0.02;
                            break;
                        case 'MOSH':
                            this.mesh.position.y = 1.5;
                            fx += (Math.random()-0.5) * 0.5 * globalSpeedMultiplier;
                            fz += (Math.random()-0.5) * 0.5 * globalSpeedMultiplier;
                            fx += (centerX - pos.x) * 0.01; fz += (centerZ - pos.z) * 0.01;
                            break;
                        case 'CIRCLE_L': case 'CIRCLE_R':
                            this.mesh.position.y = 1.5;
                            const cdx = pos.x - centerX; const cdz = pos.z - centerZ;
                            const cDist = Math.sqrt(cdx*cdx + cdz*cdz);
                            if (cDist > 15) fx -= (cdx/cDist)*0.5*globalSpeedMultiplier;
                            else if (cDist < 8) fx += (cdx/cDist)*0.5*globalSpeedMultiplier;
                            let tx = -cdz; let tz = cdx;
                            if (mode === 'CIRCLE_R') { tx = cdz; tz = -cdx; }
                            const tLen = Math.sqrt(tx*tx + tz*tz);
                            if(tLen > 0) { fx += (tx/tLen)*0.4*globalSpeedMultiplier; fz += (tz/tLen)*0.4*globalSpeedMultiplier; }
                            break;
                        case 'WOD_PREPARE':
                            this.mesh.position.y = 1.5;
                            const targetX = pos.x > 0 ? 20 : -20;
                            fx += (targetX - pos.x) * 0.05 * globalSpeedMultiplier;
                            fz += (this.originalPos.z - pos.z) * 0.05;
                            if (Math.abs(pos.x) < 3) fx += (pos.x > 0 ? 1 : -1) * 1.0 * globalSpeedMultiplier;
                            break;
                        case 'WOD_GO':
                            this.mesh.position.y = 1.5 + Math.random()*0.5;
                            if (pos.x > 1.5) fx -= 0.8 * globalSpeedMultiplier;
                            else if (pos.x < -1.5) fx += 0.8 * globalSpeedMultiplier;
                            else { fx += (Math.random()-0.5)*2.0*globalSpeedMultiplier; fz += (Math.random()-0.5)*2.0*globalSpeedMultiplier; }
                            fz += (centerZ - pos.z) * 0.02;
                            break;
                    }
                }

                this.velocity.x += fx;
                this.velocity.z += fz;
                this.velocity.multiplyScalar(FRICTION);
                const currentSpeed = this.velocity.length();
                if (currentSpeed > actualMaxSpeed) this.velocity.multiplyScalar(actualMaxSpeed / currentSpeed);
                this.mesh.position.add(this.velocity);

                if (pos.z < -10) { pos.z = -10; this.velocity.z = 0; }
                const LIMIT_X = 50; const LIMIT_Z_MAX = 50;
                if(Math.abs(pos.x) > LIMIT_X) { pos.x = Math.sign(pos.x) * LIMIT_X; this.velocity.x *= -0.5; }
                if(pos.z > LIMIT_Z_MAX) { pos.z = LIMIT_Z_MAX; this.velocity.z *= -0.5; }
            }
        }

        class Security extends Character {
            constructor(type) {
                super();
                this.type = type; // GENTLE or SCARY
                const geo = new THREE.CapsuleGeometry(0.75, 2.0, 4, 8);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, 
                    emissive: 0xffffff, 
                    emissiveIntensity: (type === 'SCARY' ? 0.8 : 0.2)
                });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.castShadow = true;
                const startX = Math.random() > 0.5 ? 30 : -30;
                this.mesh.position.set(startX, 1.75, -5);
                scene.add(this.mesh);
            }

            update(otakus) {
                const pos = this.mesh.position;
                const mySpeed = (this.type === 'SCARY') ? 0.35 : 0.15;

                let target = null;
                let minDist = 9999;
                for(let o of otakus) {
                    if (o.isFrontRow || o.isFallen) continue; 
                    const d = pos.distanceToSquared(o.mesh.position);
                    let score = d;
                    // 怖いセキュリティは速度が出ているオタクを優先
                    if (this.type === 'SCARY') score = d / (o.velocity.length() + 0.1);
                    if (score < minDist) { minDist = score; target = o; }
                }

                if (target) {
                    const dir = new THREE.Vector3().subVectors(target.mesh.position, pos).normalize();
                    this.velocity.add(dir.multiplyScalar(0.02));
                } else {
                    const dir = new THREE.Vector3(0 - pos.x, 0, 15 - pos.z).normalize();
                    this.velocity.add(dir.multiplyScalar(0.01));
                }

                this.velocity.multiplyScalar(0.9);
                if(this.velocity.length() > mySpeed) this.velocity.normalize().multiplyScalar(mySpeed);
                pos.add(this.velocity);
                
                for(let o of otakus) {
                    const dist = pos.distanceTo(o.mesh.position);
                    if (dist < 1.5) {
                        const pushDir = new THREE.Vector3().subVectors(o.mesh.position, pos).normalize();
                        if (this.type === 'GENTLE') {
                            // 優しいセキュリティ: 減速
                            o.velocity.multiplyScalar(0.5);
                            o.velocity.add(pushDir.multiplyScalar(0.05));
                            this.velocity.multiplyScalar(0.8);
                        } else if (this.type === 'SCARY') {
                            // 怖いセキュリティ: タックル
                            o.velocity.add(pushDir.multiplyScalar(1.0));
                            if (!o.isFallen && Math.random() < 0.8) o.fall();
                        }
                    }
                }
                if (pos.z < -10) pos.z = -10;
            }
        }

        // --- Main Logic ---
        const otakus = [];
        const securities = [];
        let idCounter = 0;

        function initPopulation() {
            for(let i=0; i<INITIAL_FRONT_COUNT; i++) otakus.push(new Otaku(idCounter++, true, false));
            for(let i=0; i<INITIAL_REAR_COUNT; i++) otakus.push(new Otaku(idCounter++, false, (i===0)));
            updateCountDisplay();
        }

        function modifyPopulation(type, amount) {
            const isFront = (type === 'front');
            const count = Math.abs(amount);
            const isAdding = amount > 0;

            for(let k=0; k<count; k++){
                if (isAdding) {
                    otakus.push(new Otaku(idCounter++, isFront, false));
                } else {
                    for(let i = otakus.length - 1; i >= 0; i--) {
                        const o = otakus[i];
                        if (o.isFrontRow === isFront && !o.isFC) {
                            o.dispose();
                            otakus.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            updateCountDisplay();
        }

        function modifySecurity(targetType, amount) {
            if (amount > 0) {
                securities.push(new Security(targetType));
            } else {
                for(let i = securities.length - 1; i >= 0; i--) {
                    if(securities[i].type === targetType) {
                        securities[i].dispose();
                        securities.splice(i, 1);
                        break;
                    }
                }
            }
            updateCountDisplay();
        }

        function updateCountDisplay() {
            document.getElementById('countFront').innerText = otakus.filter(o => o.isFrontRow).length;
            document.getElementById('countRear').innerText = otakus.filter(o => !o.isFrontRow).length;
            document.getElementById('countGentle').innerText = securities.filter(s => s.type === 'GENTLE').length;
            document.getElementById('countScary').innerText = securities.filter(s => s.type === 'SCARY').length;
        }

        initPopulation();

        // --- UI Event Wiring ---
        let currentMode = 'IDLE';
        const statusText = document.getElementById('statusText');
        
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            globalSpeedMultiplier = parseFloat(e.target.value);
            document.getElementById('speedVal').innerText = globalSpeedMultiplier.toFixed(1) + "x";
        });

        const bindBtn = (id, cb) => document.getElementById(id).addEventListener('click', cb);

        bindBtn('btnIdle', () => setMode('IDLE'));
        bindBtn('btnMosh', () => setMode('MOSH'));
        bindBtn('btnCircleL', () => setMode('CIRCLE_L'));
        bindBtn('btnCircleR', () => setMode('CIRCLE_R'));
        bindBtn('btnWodPrep', () => setMode('WOD_PREPARE'));
        bindBtn('btnWodGo', () => setMode('WOD_GO'));
        bindBtn('btnReset', () => { setMode('IDLE'); otakus.forEach(o=>o.reset()); });

        bindBtn('btnFrontPlus', () => modifyPopulation('front', 10));
        bindBtn('btnFrontMinus', () => modifyPopulation('front', -10));
        bindBtn('btnRearPlus', () => modifyPopulation('rear', 10));
        bindBtn('btnRearMinus', () => modifyPopulation('rear', -10));
        bindBtn('btnGentlePlus', () => modifySecurity('GENTLE', 1));
        bindBtn('btnGentleMinus', () => modifySecurity('GENTLE', -1));
        bindBtn('btnScaryPlus', () => modifySecurity('SCARY', 1));
        bindBtn('btnScaryMinus', () => modifySecurity('SCARY', -1));

        const uiContainer = document.getElementById('ui-container');
        const toggleBtn = document.getElementById('toggle-btn');
        let isMinimized = false;
        toggleBtn.addEventListener('click', () => {
            isMinimized = !isMinimized;
            if(isMinimized) {
                uiContainer.classList.add('minimized');
                toggleBtn.innerText = '▲';
            } else {
                uiContainer.classList.remove('minimized');
                toggleBtn.innerText = '▼';
            }
        });

        function setMode(mode) {
            currentMode = mode;
            let text = "";
            switch(mode){
                case 'IDLE': text = "IDLE"; break;
                case 'MOSH': text = "MOSH"; break;
                case 'CIRCLE_L': text = "CIRCLE L"; break;
                case 'CIRCLE_R': text = "CIRCLE R"; break;
                case 'WOD_PREPARE': text = "WOD PREP"; break;
                case 'WOD_GO': text = "WOD GO"; break;
            }
            statusText.innerText = text;
        }

        // --- Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); 
            
            idolGroup.children.forEach((idol, idx) => {
                idol.position.y = idolPosY + Math.sin(Date.now()*0.008 + idx)*0.2;
            });

            otakus.forEach(otaku => otaku.update(currentMode, otakus));
            securities.forEach(sec => sec.update(otakus));

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const w = container.clientWidth;
            const h = container.clientHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        });

        animate();
    </script>
</body>
</html>
